{
  "container types": [
    "matrix",
    "vector",
    "cube"
  ],
  "element types": [
    "real64",
    "complex128"
  ],
  "attributes": [
    "n_rows",
    "n_cols",
    "n_elem",
    "n_slices"
  ],
  "operators": [
    "+",
    "-",
    "*",
    "%",
    "/",
    "==",
    "!=",
    "<=",
    ">=",
    "<",
    ">",
    "&&",
    "||"
  ],
  "functions": [
    {
      "member functions": [
        {
          "at": "element access"
        },
        {
          "zeros": "set all elements to zero"
        },
        {
          "ones": "set all elements to one"
        },
        {
          "eye": "set elements along main diagonal to one and off-diagonal elements to zero"
        },
        {
          "rand": "set all elements to random values"
        },
        {
          "fill": "set all elements to specified value"
        },
        {
          "imbue": "imbue (fill) with values provided by functor or lambda function"
        },
        {
          "clean": "replace elements below a threshold with zeros"
        },
        {
          "replace": "replace specific elements with a new value"
        },
        {
          "clamp": "clamp values to lower and upper limits"
        },
        {
          "transform": "transform each element via functor or lambda function"
        },
        {
          "for_each": "apply a functor or lambda function to each element"
        },
        {
          "set_size": "change size without keeping elements (fast)"
        },
        {
          "reshape": "change size while keeping elements"
        },
        {
          "resize": "change size while keeping elements and preserving layout"
        },
        {
          "copy_size": "change size to be same as given object"
        },
        {
          "reset": "change size to empty"
        },
        {
          "submatrix views": "read/write access to contiguous and non-contiguous submatrices"
        },
        {
          "subcube views": "read/write access to contiguous and non-contiguous subcubes"
        },
        {
          "subfield views": "read/write access to contiguous subfields"
        },
        {
          "diag": "read/write access to matrix diagonals"
        },
        {
          "each_col / each_row": "vector operations applied to each column/row of matrix (aka \"broadcasting\")"
        },
        {
          "each_slice": "matrix operations applied to each slice of cube (aka \"broadcasting\")"
        },
        {
          "set_imag / set_real": "set imaginary/real part"
        },
        {
          "insert_rows/cols/slices": "insert vector/matrix/cube at specified row/column/slice"
        },
        {
          "shed_rows/cols/slices": "remove specified rows/columns/slices"
        },
        {
          "swap_rows/cols": "swap specified rows or columns"
        },
        {
          "swap": "swap contents with given object"
        },
        {
          "memptr": "raw pointer to memory"
        },
        {
          "colptr": "raw pointer to memory used by specified column"
        },
        {
          "iterators (matrices)": "iterators and associated member functions for dense matrices and vectors"
        },
        {
          "iterators (cubes)": "iterators and associated member functions for cubes"
        },
        {
          "iterators (sparse matrices)": "iterators and associated member functions for sparse matrices"
        },
        {
          "iterators (submatrices)": "iterators and associated member functions for submatrices & subcubes"
        },
        {
          "compat container functions": "compatibility container functions"
        },
        {
          "as_col / as_row": "return flattened matrix as column or row vector"
        },
        {
          "col_as_mat / row_as_mat": "return matrix representation of cube column or cube row"
        },
        {
          "t / st": "return matrix transpose"
        },
        {
          "i": "return inverse of square matrix"
        },
        {
          "min / max": "return extremum value"
        },
        {
          "index_min / index_max": "return index of extremum value"
        },
        {
          "eval": "force evaluation of delayed expression"
        },
        {
          "in_range": "check whether given location or span is valid"
        },
        {
          "is_empty": "check whether object is empty"
        },
        {
          "is_vec": "check whether matrix is a vector"
        },
        {
          "is_sorted": "check whether vector or matrix is sorted"
        },
        {
          "is_trimatu / is_trimatl": "check whether matrix is upper/lower triangular"
        },
        {
          "is_diagmat": "check whether matrix is diagonal"
        },
        {
          "is_square": "check whether matrix is square sized"
        },
        {
          "is_symmetric": "check whether matrix is symmetric"
        },
        {
          "is_hermitian": "check whether matrix is hermitian"
        },
        {
          "is_sympd": "check whether matrix is symmetric/hermitian positive definite"
        },
        {
          "is_zero": "check whether all elements are zero"
        },
        {
          "is_finite": "check whether all elements are finite"
        },
        {
          "has_inf": "check whether any element is Â±infinity"
        },
        {
          "has_nan": "check whether any element is NaN"
        },
        {
          "print": "print object to std::cout or user specified stream"
        },
        {
          "raw_print": "print object without formatting"
        },
        {
          "brief_print": "print object in shortened/abridged form"
        },
        {
          "save/load (matrices&cubes)": "save/load matrices and cubes in files or streams"
        },
        {
          "save/load (fields)": "save/load fields in files or streams"
        }
      ]
    },
    {
      "external functions": [
        {
          "generated": [
            {
              "linspace": "generate vector with linearly spaced elements"
            },
            {
              "logspace": "generate vector with logarithmically spaced elements"
            },
            {
              "regspace": "generate vector with regularly spaced elements"
            },
            {
              "randperm": "generate vector with random permutation of a sequence of integers"
            },
            {
              "eye": "generate identity matrix"
            },
            {
              "ones": "generate object filled with ones"
            },
            {
              "zeros": "generate object filled with zeros"
            },
            {
              "randu": "generate object with random values (uniform distribution)"
            },
            {
              "randn": "generate object with random values (normal distribution)"
            },
            {
              "randg": "generate object with random values (gamma distribution)"
            },
            {
              "randi": "generate object with random integer values in specified interval"
            },
            {
              "speye": "generate sparse identity matrix"
            },
            {
              "spones": "generate sparse matrix with non-zero elements set to one"
            },
            {
              "sprandu / sprandn": "generate sparse matrix with non-zero elements set to random values"
            },
            {
              "toeplitz": "generate Toeplitz matrix"
            }
          ]
        },
        {
          "external": [
            {
              "abs": "obtain magnitude of each element"
            },
            {
              "accu": "accumulate (sum) all elements"
            },
            {
              "affmul": "affine matrix multiplication"
            },
            {
              "all": "check whether all elements are non-zero, or satisfy a relational condition"
            },
            {
              "any": "check whether any element is non-zero, or satisfies a relational condition"
            },
            {
              "approx_equal": "approximate equality"
            },
            {
              "arg": "phase angle of each element"
            },
            {
              "as_scalar": "convert 1x1 matrix to pure scalar"
            },
            {
              "clamp": "obtain clamped elements according to given limits"
            },
            {
              "cond": "condition number of matrix"
            },
            {
              "conj": "obtain complex conjugate of each element"
            },
            {
              "conv_to": "convert/cast between matrix types"
            },
            {
              "cross": "cross product"
            },
            {
              "cumsum": "cumulative sum"
            },
            {
              "cumprod": "cumulative product"
            },
            {
              "det": "determinant"
            },
            {
              "diagmat": "generate diagonal matrix from given matrix or vector"
            },
            {
              "diagvec": "extract specified diagonal"
            },
            {
              "diags / spdiags": "generate band matrix from given set of vectors"
            },
            {
              "diff": "differences between adjacent elements"
            },
            {
              "dot / cdot / norm_dot": "dot product"
            },
            {
              "eps": "obtain distance of each element to next largest floating point representation"
            },
            {
              "expmat": "matrix exponential"
            },
            {
              "expmat_sym": "matrix exponential of symmetric matrix"
            },
            {
              "find": "find indices of non-zero elements, or elements satisfying a relational condition"
            },
            {
              "find_finite": "find indices of finite elements"
            },
            {
              "find_nonfinite": "find indices of non-finite elements"
            },
            {
              "find_nan": "find indices of NaN elements"
            },
            {
              "find_unique": "find indices of unique elements"
            },
            {
              "fliplr / flipud": "flip matrix left to right or upside down"
            },
            {
              "imag / real": "extract imaginary/real part"
            },
            {
              "ind2sub": "convert linear index to subscripts"
            },
            {
              "index_min / index_max": "indices of extremum values"
            },
            {
              "inplace_trans": "in-place transpose"
            },
            {
              "intersect": "find common elements in two vectors/matrices"
            },
            {
              "join_rows / join_cols": "concatenation of matrices"
            },
            {
              "join_slices": "concatenation of cubes"
            },
            {
              "kron": "Kronecker tensor product"
            },
            {
              "log_det": "log determinant"
            },
            {
              "log_det_sympd": "log determinant of symmetric positive definite matrix"
            },
            {
              "logmat": "matrix logarithm"
            },
            {
              "logmat_sympd": "matrix logarithm of symmetric matrix"
            },
            {
              "min / max": "return extremum values"
            },
            {
              "nonzeros": "return non-zero values"
            },
            {
              "norm": "various norms of vectors and matrices"
            },
            {
              "norm2est": "fast estimate of the matrix 2-norm"
            },
            {
              "normalise": "normalise vectors to unit p-norm"
            },
            {
              "pow": "element-wise power"
            },
            {
              "powmat": "matrix power"
            },
            {
              "prod": "product of elements"
            },
            {
              "rank": "rank of matrix"
            },
            {
              "rcond": "reciprocal condition number"
            },
            {
              "repelem": "replicate elements"
            },
            {
              "repmat": "replicate matrix in block-like fashion"
            },
            {
              "reshape": "change size while keeping elements"
            },
            {
              "resize": "change size while keeping elements and preserving layout"
            },
            {
              "reverse": "reverse order of elements"
            },
            {
              "roots": "roots of polynomial"
            },
            {
              "shift": "shift elements"
            },
            {
              "shuffle": "randomly shuffle elements"
            },
            {
              "size": "obtain dimensions of given object"
            },
            {
              "sort": "sort elements"
            },
            {
              "sort_index": "vector describing sorted order of elements"
            },
            {
              "sqrtmat": "square root of matrix"
            },
            {
              "sqrtmat_sympd": "square root of symmetric matrix"
            },
            {
              "sum": "sum of elements"
            },
            {
              "sub2ind": "convert subscripts to linear index"
            },
            {
              "symmatu / symmatl": "generate symmetric matrix from given matrix"
            },
            {
              "trace": "sum of diagonal elements"
            },
            {
              "trans": "transpose of matrix"
            },
            {
              "trapz": "trapezoidal numerical integration"
            },
            {
              "trimatu / trimatl": "copy upper/lower triangular part"
            },
            {
              "trimatu_ind / trimatl_ind": "obtain indices of upper/lower triangular part"
            },
            {
              "unique": "return unique elements"
            },
            {
              "vecnorm": "obtain vector norm of each row or column of a matrix"
            },
            {
              "vectorise": "flatten matrix into vector"
            },
            {
              "misc functions": "miscellaneous element-wise functions: exp, log, sqrt, round, sign, ..."
            },
            {
              "trig functions": "trigonometric element-wise functions: cos, sin, tan, ..."
            }
          ]
        },
        {
          "dense matrix": [
            {
              "chol": "Cholesky decomposition"
            },
            {
              "eig_sym": "eigen decomposition of dense symmetric/hermitian matrix"
            },
            {
              "eig_gen": "eigen decomposition of dense general square matrix"
            },
            {
              "eig_pair": "eigen decomposition for pair of general dense square matrices"
            },
            {
              "hess": "upper Hessenberg decomposition"
            },
            {
              "inv": "inverse of general square matrix"
            },
            {
              "inv_sympd": "inverse of symmetric positive definite matrix"
            },
            {
              "lu": "lower-upper decomposition"
            },
            {
              "null": "orthonormal basis of null space"
            },
            {
              "orth": "orthonormal basis of range space"
            },
            {
              "pinv": "pseudo-inverse / generalised inverse"
            },
            {
              "qr": "QR decomposition"
            },
            {
              "qr_econ": "economical QR decomposition"
            },
            {
              "qz": "generalised Schur decomposition"
            },
            {
              "schur": "Schur decomposition"
            },
            {
              "solve": "solve systems of linear equations"
            },
            {
              "svd": "singular value decomposition"
            },
            {
              "svd_econ": "economical singular value decomposition"
            },
            {
              "syl": "Sylvester equation solver"
            }
          ]
        },
        {
          "sparse matrix": [
            {
              "eigs_sym": "limited number of eigenvalues & eigenvectors of sparse symmetric real matrix"
            },
            {
              "eigs_gen": "limited number of eigenvalues & eigenvectors of sparse general square matrix"
            },
            {
              "svds": "truncated svd: limited number of singular values & singular vectors of sparse matrix"
            },
            {
              "spsolve": "solve sparse systems of linear equations"
            },
            {
              "spsolve_factoriser": "factoriser for solving sparse systems of linear equations"
            }
          ]
        },
        {
          "signal & image processing": [
            {
              "conv": "1D convolution"
            },
            {
              "conv2": "2D convolution"
            },
            {
              "fft / ifft": "1D fast Fourier transform and its inverse"
            },
            {
              "fft2 / ifft2": "2D fast Fourier transform and its inverse"
            },
            {
              "interp1": "1D interpolation"
            },
            {
              "interp2": "2D interpolation"
            },
            {
              "polyfit": "find polynomial coefficients for data fitting"
            },
            {
              "polyval": "evaluate polynomial"
            }
          ]
        },
        {
          "statistics & clustering": [
            {
              "stats functions": "mean, median, standard deviation, variance"
            },
            {
              "cov": "covariance"
            },
            {
              "cor": "correlation"
            },
            {
              "hist": "histogram of counts"
            },
            {
              "histc": "histogram of counts with user specified edges"
            },
            {
              "quantile": "quantiles of a dataset"
            },
            {
              "princomp": "principal component analysis (PCA)"
            },
            {
              "normpdf": "probability density function of normal distribution"
            },
            {
              "log_normpdf": "logarithm version of probability density function of normal distribution"
            },
            {
              "normcdf": "cumulative distribution function of normal distribution"
            },
            {
              "mvnrnd": "random vectors from multivariate normal distribution"
            },
            {
              "chi2rnd": "random numbers from chi-squared distribution"
            },
            {
              "wishrnd": "random matrix from Wishart distribution"
            },
            {
              "iwishrnd": "random matrix from inverse Wishart distribution"
            },
            {
              "running_stat": "running statistics of scalars (one dimensional process/signal)"
            },
            {
              "running_stat_vec": "running statistics of vectors (multi-dimensional process/signal)"
            },
            {
              "kmeans": "cluster data into disjoint sets"
            },
            {
              "gmm_diag/gmm_full": "model and evaluate data using Gaussian Mixture Models (GMMs)"
            }
          ]
        },
        {
          "miscellaneous": [
            {
              "constants": "pi, inf, NaN, eps, speed of light, ..."
            },
            {
              "wall_clock": "timer for measuring number of elapsed seconds"
            },
            {
              "RNG seed setting": "functions for changing RNG seeds"
            },
            {
              "output streams": "streams for printing warnings and errors"
            },
            {
              "uword / sword": "shorthand for unsigned and signed integers"
            },
            {
              "cx_double / cx_float": "shorthand for std::complex<double> and std::complex<float>"
            },
            {
              "Matlab/Armadillo syntax differences": "examples of Matlab syntax and conceptually corresponding Armadillo syntax"
            },
            {
              "example program": "short example program"
            },
            {
              "config.hpp": "configuration options"
            },
            {
              "API additions": "API stability and list of API additions"
            }
          ]
        }
      ]
    }
  ],
  "function categories": [
    {
      "dense matrix": [
        "decompositions",
        "factorisations",
        "inverses",
        "equation solvers"
      ]
    },
    {
      "sparse matrix": [
        "decompositions",
        "factorisations",
        "inverses",
        "equation solvers"
      ]
    },
    {
      "signal & image processing": "..."
    },
    {
      "statistics and clustering": "..."
    },
    {
      "miscellaneous": [
        "constants",
        "configuration options",
        "..."
      ]
    }
  ]
}